# 共享汽车运维自动调度系统开发方案

## 1. 开发方案概述

### 1.1 开发目标
基于需求文档，开发一套完整的共享汽车运维自动调度系统，实现车辆调度的智能化、自动化和数据化管理。

### 1.2 开发原则
- **模块化设计**：系统采用微服务架构，各模块独立开发和部署
- **数据驱动**：所有调度决策基于实时数据和算法分析
- **用户友好**：界面简洁直观，操作流程简化
- **高可用性**：系统7×24小时稳定运行
- **可扩展性**：支持业务规模扩展和功能迭代

## 2. 技术架构详细设计

### 2.1 微服务架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        前端应用层                                │
├─────────────────┬─────────────────┬─────────────────────────────┤
│   运维管理后台   │   移动端APP     │        数据大屏             │
│   (Vue.js)      │   (Flutter)     │       (Vue.js)              │
└─────────────────┴─────────────────┴─────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────────┐
│                        API网关层                                │
│                    (Spring Cloud Gateway)                      │
└─────────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────────┐
│                        业务服务层                               │
├─────────────┬─────────────┬─────────────┬─────────────────────┤
│  车辆监控    │  网点管理    │  调度引擎    │     数据分析        │
│  服务        │  服务        │  服务        │     服务            │
├─────────────┼─────────────┼─────────────┼─────────────────────┤
│  用户管理    │  消息推送    │  地图服务    │     报表生成        │
│  服务        │  服务        │  服务        │     服务            │
└─────────────┴─────────────┴─────────────┴─────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────────┐
│                        数据存储层                               │
├─────────────┬─────────────┬─────────────┬─────────────────────┤
│   MySQL      │   Redis     │  InfluxDB   │     Elasticsearch   │
│  (业务数据)   │  (缓存)     │ (时序数据)   │    (搜索引擎)       │
└─────────────┴─────────────┴─────────────┴─────────────────────┘
```

### 2.2 核心服务详细设计

#### 2.2.1 车辆监控服务 (Vehicle Monitor Service)

**服务职责**：
- 接收车载设备数据
- 车辆状态实时监控
- 位置信息处理
- 异常告警处理

**技术实现**：
```java
@RestController
@RequestMapping("/api/v1/vehicles")
public class VehicleMonitorController {
    
    @Autowired
    private VehicleMonitorService vehicleMonitorService;
    
    @PostMapping("/location")
    public ResponseEntity<ApiResponse> updateLocation(
            @RequestBody VehicleLocationDto locationDto) {
        vehicleMonitorService.updateVehicleLocation(locationDto);
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    @GetMapping("/{vehicleId}/status")
    public ResponseEntity<VehicleStatusDto> getVehicleStatus(
            @PathVariable Long vehicleId) {
        VehicleStatusDto status = vehicleMonitorService.getVehicleStatus(vehicleId);
        return ResponseEntity.ok(status);
    }
}
```

**数据处理流程**：
1. 车载设备通过HTTP/MQTT推送位置数据
2. 数据验证和清洗
3. 存储到InfluxDB时序数据库
4. 更新Redis缓存中的实时状态
5. 触发位置变化事件

#### 2.2.2 网点管理服务 (Station Management Service)

**服务职责**：
- 网点车辆数量统计
- "2-1-2"规则监控
- 网点状态管理
- 需求预测分析

**核心算法实现**：
```java
@Service
public class StationManagementService {
    
    @EventListener
    public void handleVehicleLocationChange(VehicleLocationChangeEvent event) {
        // 计算车辆所在网点
        Station station = calculateVehicleStation(event.getLocation());
        
        // 更新网点车辆数量
        updateStationVehicleCount(station.getId());
        
        // 检查是否触发调度规则
        checkDispatchRules(station);
    }
    
    private void checkDispatchRules(Station station) {
        int currentCount = getCurrentVehicleCount(station.getId());
        int targetCount = station.getTargetVehicleCount();
        
        if (currentCount < targetCount) {
            // 触发补充调度
            dispatchService.createSupplementTask(station.getId());
        } else if (currentCount > targetCount) {
            // 触发回收调度
            dispatchService.createRetrieveTask(station.getId());
        }
    }
}
```

#### 2.2.3 调度引擎服务 (Dispatch Engine Service)

**服务职责**：
- 调度任务生成
- 最优路径计算
- 任务分配算法
- 执行状态跟踪

**调度算法实现**：
```java
@Service
public class DispatchEngineService {
    
    public DispatchTask createSupplementTask(Long stationId) {
        // 1. 查找最近的可用车辆
        Vehicle nearestVehicle = findNearestAvailableVehicle(stationId);
        
        // 2. 查找最适合的运维人员
        Staff assignedStaff = findOptimalStaff(nearestVehicle.getLocation(), stationId);
        
        // 3. 计算最优路径
        Route optimalRoute = calculateOptimalRoute(
            nearestVehicle.getLocation(), 
            getStationLocation(stationId)
        );
        
        // 4. 创建调度任务
        DispatchTask task = DispatchTask.builder()
            .taskType(TaskType.SUPPLEMENT)
            .vehicleId(nearestVehicle.getId())
            .targetStationId(stationId)
            .assignedStaffId(assignedStaff.getId())
            .estimatedDuration(optimalRoute.getDuration())
            .priority(calculatePriority(stationId))
            .build();
            
        return dispatchTaskRepository.save(task);
    }
    
    private Vehicle findNearestAvailableVehicle(Long stationId) {
        Location stationLocation = getStationLocation(stationId);
        
        return vehicleRepository.findAvailableVehicles()
            .stream()
            .min(Comparator.comparing(vehicle -> 
                calculateDistance(vehicle.getLocation(), stationLocation)
            ))
            .orElseThrow(() -> new NoAvailableVehicleException());
    }
}
```

### 2.3 数据库设计实现

#### 2.3.1 MySQL数据库设计

**车辆表优化设计**：
```sql
CREATE TABLE vehicles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    license_plate VARCHAR(20) NOT NULL UNIQUE,
    vehicle_model VARCHAR(50) NOT NULL,
    device_id VARCHAR(50) NOT NULL UNIQUE,
    maintenance_mileage INT DEFAULT 5000,
    current_mileage INT DEFAULT 0,
    last_maintenance_mileage INT DEFAULT 0,
    status ENUM('online', 'offline', 'maintenance', 'fault') DEFAULT 'offline',
    battery_level DECIMAL(5,2) DEFAULT 0,
    fuel_level DECIMAL(5,2) DEFAULT 0,
    current_station_id BIGINT,
    maintenance_center_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_status (status),
    INDEX idx_station (current_station_id),
    INDEX idx_device (device_id),
    FOREIGN KEY (current_station_id) REFERENCES stations(id),
    FOREIGN KEY (maintenance_center_id) REFERENCES maintenance_centers(id)
);
```

**网点表设计**：
```sql
CREATE TABLE stations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    station_code VARCHAR(20) NOT NULL UNIQUE,
    station_name VARCHAR(100) NOT NULL,
    latitude DECIMAL(10,7) NOT NULL,
    longitude DECIMAL(10,7) NOT NULL,
    radius INT DEFAULT 50,
    target_vehicle_count INT DEFAULT 2,
    current_vehicle_count INT DEFAULT 0,
    maintenance_center_id BIGINT NOT NULL,
    district VARCHAR(50),
    address VARCHAR(200),
    status ENUM('active', 'inactive', 'maintenance') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_location (latitude, longitude),
    INDEX idx_center (maintenance_center_id),
    INDEX idx_status (status),
    FOREIGN KEY (maintenance_center_id) REFERENCES maintenance_centers(id)
);
```

#### 2.3.2 Redis缓存设计

**缓存策略**：
```java
@Service
public class VehicleCacheService {
    
    private static final String VEHICLE_STATUS_KEY = "vehicle:status:";
    private static final String STATION_COUNT_KEY = "station:count:";
    private static final int CACHE_EXPIRE_SECONDS = 300; // 5分钟过期
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void cacheVehicleStatus(Long vehicleId, VehicleStatus status) {
        String key = VEHICLE_STATUS_KEY + vehicleId;
        redisTemplate.opsForValue().set(key, status, CACHE_EXPIRE_SECONDS, TimeUnit.SECONDS);
    }
    
    public VehicleStatus getVehicleStatus(Long vehicleId) {
        String key = VEHICLE_STATUS_KEY + vehicleId;
        return (VehicleStatus) redisTemplate.opsForValue().get(key);
    }
    
    public void updateStationVehicleCount(Long stationId, Integer count) {
        String key = STATION_COUNT_KEY + stationId;
        redisTemplate.opsForValue().set(key, count);
        
        // 发布网点车辆数变化事件
        redisTemplate.convertAndSend("station:count:change", 
            new StationCountChangeEvent(stationId, count));
    }
}
```

#### 2.3.3 InfluxDB时序数据设计

**数据写入服务**：
```java
@Service
public class TimeSeriesDataService {
    
    @Autowired
    private InfluxDBClient influxDBClient;
    
    public void writeVehicleLocation(VehicleLocationDto locationDto) {
        Point point = Point.measurement("vehicle_location")
            .addTag("vehicle_id", locationDto.getVehicleId().toString())
            .addTag("license_plate", locationDto.getLicensePlate())
            .addField("latitude", locationDto.getLatitude())
            .addField("longitude", locationDto.getLongitude())
            .addField("speed", locationDto.getSpeed())
            .addField("direction", locationDto.getDirection())
            .addField("battery_level", locationDto.getBatteryLevel())
            .time(locationDto.getTimestamp(), WritePrecision.S);
            
        influxDBClient.getWriteApiBlocking().writePoint(point);
    }
    
    public List<VehicleLocationHistory> queryVehicleTrack(
            Long vehicleId, Instant start, Instant end) {
        String query = String.format(
            "from(bucket: \"vehicle_data\")" +
            "|> range(start: %s, stop: %s)" +
            "|> filter(fn: (r) => r._measurement == \"vehicle_location\")" +
            "|> filter(fn: (r) => r.vehicle_id == \"%d\")",
            start, end, vehicleId
        );
        
        return influxDBClient.getQueryApi()
            .query(query, VehicleLocationHistory.class);
    }
}
```

## 3. 前端开发方案

### 3.1 Web管理后台 (Vue.js 3 + Element Plus)

#### 3.1.1 项目结构
```
src/
├── components/          # 公共组件
│   ├── VehicleMap/     # 车辆地图组件
│   ├── StationList/    # 网点列表组件
│   └── TaskPanel/      # 任务面板组件
├── views/              # 页面视图
│   ├── Dashboard/      # 仪表盘
│   ├── VehicleManage/  # 车辆管理
│   ├── StationManage/  # 网点管理
│   ├── DispatchManage/ # 调度管理
│   └── Analytics/      # 数据分析
├── store/              # Vuex状态管理
├── api/                # API接口
├── utils/              # 工具函数
└── router/             # 路由配置
```

#### 3.1.2 核心组件实现

**车辆地图组件**：
```vue
<template>
  <div class="vehicle-map">
    <div id="map-container" ref="mapContainer"></div>
    <div class="map-controls">
      <el-select v-model="selectedCenter" @change="onCenterChange">
        <el-option 
          v-for="center in maintenanceCenters" 
          :key="center.id"
          :label="center.name"
          :value="center.id">
        </el-option>
      </el-select>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue'
import AMapLoader from '@amap/amap-jsapi-loader'
import { getVehicleLocations, getStations } from '@/api/vehicle'

const mapContainer = ref(null)
const map = ref(null)
const vehicleMarkers = ref([])
const stationMarkers = ref([])
const selectedCenter = ref(null)

onMounted(async () => {
  await initMap()
  await loadVehiclesAndStations()
  startRealTimeUpdate()
})

const initMap = async () => {
  const AMap = await AMapLoader.load({
    key: 'your-amap-key',
    version: '2.0'
  })
  
  map.value = new AMap.Map(mapContainer.value, {
    zoom: 12,
    center: [104.066801, 30.572815] // 成都中心
  })
}

const loadVehiclesAndStations = async () => {
  try {
    const [vehiclesRes, stationsRes] = await Promise.all([
      getVehicleLocations({ centerId: selectedCenter.value }),
      getStations({ centerId: selectedCenter.value })
    ])
    
    updateVehicleMarkers(vehiclesRes.data.vehicles)
    updateStationMarkers(stationsRes.data.stations)
  } catch (error) {
    console.error('加载地图数据失败:', error)
  }
}

const updateVehicleMarkers = (vehicles) => {
  // 清除现有标记
  vehicleMarkers.value.forEach(marker => map.value.remove(marker))
  vehicleMarkers.value = []
  
  // 添加车辆标记
  vehicles.forEach(vehicle => {
    const marker = new AMap.Marker({
      position: [vehicle.longitude, vehicle.latitude],
      icon: getVehicleIcon(vehicle.status),
      title: vehicle.licensePlate
    })
    
    marker.setExtData(vehicle)
    marker.on('click', onVehicleClick)
    
    map.value.add(marker)
    vehicleMarkers.value.push(marker)
  })
}

const getVehicleIcon = (status) => {
  const iconMap = {
    online: '/icons/vehicle-online.png',
    offline: '/icons/vehicle-offline.png',
    maintenance: '/icons/vehicle-maintenance.png'
  }
  return iconMap[status] || iconMap.offline
}

const startRealTimeUpdate = () => {
  setInterval(() => {
    loadVehiclesAndStations()
  }, 30000) // 30秒更新一次
}
</script>
```

### 3.2 移动端APP (Flutter)

#### 3.2.1 项目结构
```
lib/
├── main.dart
├── app/
│   ├── routes/         # 路由配置
│   └── theme/          # 主题配置
├── features/           # 功能模块
│   ├── auth/          # 认证模块
│   ├── dashboard/     # 仪表盘
│   ├── tasks/         # 任务管理
│   └── profile/       # 个人中心
├── shared/            # 共享模块
│   ├── models/        # 数据模型
│   ├── services/      # 服务层
│   ├── widgets/       # 公共组件
│   └── utils/         # 工具函数
└── core/              # 核心模块
    ├── network/       # 网络请求
    ├── storage/       # 本地存储
    └── constants/     # 常量定义
```

#### 3.2.2 核心页面实现

**任务列表页面**：
```dart
class TaskListPage extends StatefulWidget {
  @override
  _TaskListPageState createState() => _TaskListPageState();
}

class _TaskListPageState extends State<TaskListPage> {
  final TaskService _taskService = GetIt.instance<TaskService>();
  List<DispatchTask> _tasks = [];
  bool _isLoading = true;
  
  @override
  void initState() {
    super.initState();
    _loadTasks();
    _startRealTimeUpdate();
  }
  
  Future<void> _loadTasks() async {
    try {
      final tasks = await _taskService.getPendingTasks();
      setState(() {
        _tasks = tasks;
        _isLoading = false;
      });
    } catch (e) {
      _showErrorSnackBar('加载任务失败: $e');
    }
  }
  
  void _startRealTimeUpdate() {
    Timer.periodic(Duration(seconds: 30), (timer) {
      if (mounted) {
        _loadTasks();
      } else {
        timer.cancel();
      }
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('调度任务'),
        actions: [
          IconButton(
            icon: Icon(Icons.refresh),
            onPressed: _loadTasks,
          ),
        ],
      ),
      body: _isLoading
          ? Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _loadTasks,
              child: ListView.builder(
                itemCount: _tasks.length,
                itemBuilder: (context, index) {
                  return TaskCard(
                    task: _tasks[index],
                    onAccept: () => _acceptTask(_tasks[index]),
                    onComplete: () => _completeTask(_tasks[index]),
                  );
                },
              ),
            ),
    );
  }
  
  Future<void> _acceptTask(DispatchTask task) async {
    try {
      await _taskService.acceptTask(task.id);
      _loadTasks();
      _showSuccessSnackBar('任务已接受');
    } catch (e) {
      _showErrorSnackBar('接受任务失败: $e');
    }
  }
}
```

## 4. 核心算法实现

### 4.1 车辆调度算法

#### 4.1.1 最近车辆查找算法
```java
@Component
public class VehicleDispatchAlgorithm {
    
    /**
     * 查找最近的可用车辆
     * 使用改进的A*算法考虑实际路况
     */
    public Vehicle findNearestAvailableVehicle(Location targetLocation, 
                                               List<Vehicle> availableVehicles) {
        return availableVehicles.parallelStream()
            .filter(this::isVehicleAvailable)
            .min(Comparator.comparing(vehicle -> 
                calculateRealDistance(vehicle.getLocation(), targetLocation)
            ))
            .orElse(null);
    }
    
    /**
     * 计算实际行驶距离（考虑路况）
     */
    private double calculateRealDistance(Location from, Location to) {
        // 1. 计算直线距离
        double straightDistance = calculateStraightDistance(from, to);
        
        // 2. 获取实际路径距离
        RouteInfo routeInfo = mapService.calculateRoute(from, to);
        
        // 3. 考虑交通状况的权重
        double trafficWeight = getTrafficWeight(routeInfo);
        
        return routeInfo.getDistance() * trafficWeight;
    }
    
    /**
     * 获取交通状况权重
     */
    private double getTrafficWeight(RouteInfo routeInfo) {
        TrafficStatus status = routeInfo.getTrafficStatus();
        switch (status) {
            case SMOOTH: return 1.0;
            case SLOW: return 1.3;
            case CONGESTED: return 1.8;
            case SEVERE: return 2.5;
            default: return 1.2;
        }
    }
}
```

#### 4.1.2 运维人员分配算法
```java
@Component
public class StaffAssignmentAlgorithm {
    
    /**
     * 智能分配运维人员
     * 考虑距离、工作负荷、技能匹配等因素
     */
    public Staff assignOptimalStaff(DispatchTask task, List<Staff> availableStaff) {
        return availableStaff.stream()
            .filter(staff -> isStaffAvailable(staff))
            .max(Comparator.comparing(staff -> calculateStaffScore(staff, task)))
            .orElse(null);
    }
    
    /**
     * 计算运维人员适配分数
     */
    private double calculateStaffScore(Staff staff, DispatchTask task) {
        double distanceScore = calculateDistanceScore(staff, task);
        double workloadScore = calculateWorkloadScore(staff);
        double skillScore = calculateSkillScore(staff, task);
        
        // 加权计算总分
        return distanceScore * 0.4 + workloadScore * 0.3 + skillScore * 0.3;
    }
    
    /**
     * 距离分数（距离越近分数越高）
     */
    private double calculateDistanceScore(Staff staff, DispatchTask task) {
        double distance = calculateDistance(staff.getCurrentLocation(), 
                                          task.getSourceLocation());
        // 距离在5公里内得满分，超过20公里得0分
        return Math.max(0, (20 - distance) / 15);
    }
    
    /**
     * 工作负荷分数（负荷越轻分数越高）
     */
    private double calculateWorkloadScore(Staff staff) {
        int currentTasks = staff.getCurrentTaskCount();
        int maxTasks = staff.getMaxTaskCapacity();
        return (double)(maxTasks - currentTasks) / maxTasks;
    }
    
    /**
     * 技能匹配分数
     */
    private double calculateSkillScore(Staff staff, DispatchTask task) {
        if (task.getTaskType() == TaskType.MAINTENANCE) {
            return staff.hasMaintenanceSkill() ? 1.0 : 0.5;
        }
        return 1.0; // 普通调度任务不需要特殊技能
    }
}
```

### 4.2 需求预测算法

#### 4.2.1 时间序列预测
```java
@Component
public class DemandPredictionAlgorithm {
    
    /**
     * 基于历史数据预测网点需求
     * 使用ARIMA模型和机器学习算法
     */
    public DemandForecast predictStationDemand(Long stationId, 
                                               LocalDateTime targetTime) {
        // 1. 获取历史数据
        List<StationUsageHistory> history = getStationUsageHistory(stationId, 
                                                                   targetTime.minusDays(30), 
                                                                   targetTime);
        
        // 2. 特征工程
        List<DemandFeature> features = extractFeatures(history, targetTime);
        
        // 3. 时间序列分析
        double timeSeriesPrediction = arimaPredict(history, targetTime);
        
        // 4. 机器学习预测
        double mlPrediction = mlModelPredict(features);
        
        // 5. 集成预测结果
        double finalPrediction = combinepredictions(timeSeriesPrediction, mlPrediction);
        
        return DemandForecast.builder()
            .stationId(stationId)
            .targetTime(targetTime)
            .predictedDemand(finalPrediction)
            .confidence(calculateConfidence(history))
            .build();
    }
    
    /**
     * 特征提取
     */
    private List<DemandFeature> extractFeatures(List<StationUsageHistory> history, 
                                                LocalDateTime targetTime) {
        List<DemandFeature> features = new ArrayList<>();
        
        // 时间特征
        features.add(new DemandFeature("hour", targetTime.getHour()));
        features.add(new DemandFeature("dayOfWeek", targetTime.getDayOfWeek().getValue()));
        features.add(new DemandFeature("dayOfMonth", targetTime.getDayOfMonth()));
        features.add(new DemandFeature("month", targetTime.getMonthValue()));
        
        // 天气特征
        WeatherInfo weather = weatherService.getWeatherForecast(targetTime);
        features.add(new DemandFeature("temperature", weather.getTemperature()));
        features.add(new DemandFeature("rainfall", weather.getRainfall()));
        features.add(new DemandFeature("windSpeed", weather.getWindSpeed()));
        
        // 历史统计特征
        double avgDemand = calculateAverageDemand(history);
        double trendSlope = calculateTrend(history);
        features.add(new DemandFeature("avgDemand", avgDemand));
        features.add(new DemandFeature("trend", trendSlope));
        
        // 节假日特征
        boolean isHoliday = holidayService.isHoliday(targetTime.toLocalDate());
        features.add(new DemandFeature("isHoliday", isHoliday ? 1.0 : 0.0));
        
        return features;
    }
}
```

## 5. 消息推送系统

### 5.1 实时消息推送架构

```java
@Component
public class MessagePushService {
    
    @Autowired
    private WebSocketSessionManager sessionManager;
    
    @Autowired
    private FCMService fcmService;
    
    @Autowired
    private SMSService smsService;
    
    /**
     * 推送调度任务
     */
    public void pushDispatchTask(DispatchTask task) {
        Staff assignedStaff = task.getAssignedStaff();
        
        // 构建消息内容
        TaskMessage message = TaskMessage.builder()
            .taskId(task.getId())
            .taskType(task.getTaskType())
            .priority(task.getPriority())
            .sourceStation(task.getSourceStation())
            .targetStation(task.getTargetStation())
            .estimatedDuration(task.getEstimatedDuration())
            .build();
        
        // 多渠道推送
        CompletableFuture.allOf(
            // WebSocket推送（实时）
            CompletableFuture.runAsync(() -> 
                pushWebSocketMessage(assignedStaff.getId(), message)),
            
            // 移动推送（离线时）
            CompletableFuture.runAsync(() -> 
                pushMobileNotification(assignedStaff.getDeviceToken(), message)),
            
            // 短信推送（紧急任务）
            CompletableFuture.runAsync(() -> {
                if (task.getPriority() >= 4) {
                    pushSMSNotification(assignedStaff.getPhoneNumber(), message);
                }
            })
        );
    }
    
    /**
     * WebSocket实时推送
     */
    private void pushWebSocketMessage(Long staffId, TaskMessage message) {
        WebSocketSession session = sessionManager.getSession(staffId);
        if (session != null && session.isOpen()) {
            try {
                session.sendMessage(new TextMessage(JSON.toJSONString(message)));
            } catch (IOException e) {
                log.error("WebSocket推送失败", e);
            }
        }
    }
    
    /**
     * 移动端推送
     */
    private void pushMobileNotification(String deviceToken, TaskMessage message) {
        if (StringUtils.isNotBlank(deviceToken)) {
            fcmService.sendNotification(deviceToken, 
                "新调度任务", 
                message.getDescription());
        }
    }
    
    /**
     * 短信推送
     */
    private void pushSMSNotification(String phoneNumber, TaskMessage message) {
        if (StringUtils.isNotBlank(phoneNumber)) {
            String smsContent = String.format(
                "【车辆调度】紧急任务：%s，请及时处理。任务ID：%d", 
                message.getDescription(), 
                message.getTaskId());
            smsService.sendSMS(phoneNumber, smsContent);
        }
    }
}
```

### 5.2 WebSocket配置

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new TaskWebSocketHandler(), "/ws/tasks")
                .setAllowedOrigins("*")
                .withSockJS();
    }
}

@Component
public class TaskWebSocketHandler extends TextWebSocketHandler {
    
    @Autowired
    private WebSocketSessionManager sessionManager;
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String staffId = getStaffIdFromSession(session);
        sessionManager.addSession(Long.valueOf(staffId), session);
        log.info("WebSocket连接建立，用户ID: {}", staffId);
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        String staffId = getStaffIdFromSession(session);
        sessionManager.removeSession(Long.valueOf(staffId));
        log.info("WebSocket连接关闭，用户ID: {}", staffId);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        // 处理客户端消息
        String payload = message.getPayload();
        log.info("收到WebSocket消息: {}", payload);
        
        // 解析消息并处理
        try {
            WebSocketMessage wsMessage = JSON.parseObject(payload, WebSocketMessage.class);
            handleClientMessage(session, wsMessage);
        } catch (Exception e) {
            log.error("处理WebSocket消息失败", e);
        }
    }
}
```

## 6. 监控和运维

### 6.1 系统监控配置

#### 6.1.1 Prometheus监控配置
```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'dispatch-system'
    static_configs:
      - targets: ['localhost:8080', 'localhost:8081', 'localhost:8082']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 10s

  - job_name: 'mysql-exporter'
    static_configs:
      - targets: ['localhost:9104']

  - job_name: 'redis-exporter'
    static_configs:
      - targets: ['localhost:9121']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

#### 6.1.2 告警规则配置
```yaml
# alert_rules.yml
groups:
  - name: dispatch_system_alerts
    rules:
      - alert: HighCPUUsage
        expr: cpu_usage_percent > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率过高"
          description: "{{ $labels.instance }} CPU使用率超过80%，当前值: {{ $value }}%"

      - alert: HighMemoryUsage
        expr: memory_usage_percent > 85
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "内存使用率过高"
          description: "{{ $labels.instance }} 内存使用率超过85%，当前值: {{ $value }}%"

      - alert: VehicleOfflineRate
        expr: (offline_vehicles / total_vehicles) * 100 > 5
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "车辆离线率过高"
          description: "车辆离线率超过5%，当前值: {{ $value }}%"

      - alert: DispatchDelayHigh
        expr: avg_dispatch_response_time > 1800
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "调度响应时间过长"
          description: "平均调度响应时间超过30分钟，当前值: {{ $value }}秒"
```

### 6.2 日志管理

#### 6.2.1 Logback配置
```xml
<!-- logback-spring.xml -->
<configuration>
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/dispatch-system.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/dispatch-system.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <timeBasedFileNamingAndTriggeringPolicy 
                    class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                    <maxFileSize>100MB</maxFileSize>
                </timeBasedFileNamingAndTriggeringPolicy>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
        
        <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
            <destination>logstash:5000</destination>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <version/>
                    <logLevel/>
                    <message/>
                    <mdc/>
                    <arguments/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="FILE"/>
            <appender-ref ref="LOGSTASH"/>
        </root>
    </springProfile>
</configuration>
```

## 7. 部署和CI/CD

### 7.1 Docker配置

#### 7.1.1 应用Dockerfile
```dockerfile
# Dockerfile
FROM openjdk:11-jre-slim

VOLUME /tmp

ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar

# 添加应用配置
COPY src/main/resources/application-prod.yml /app/config/

# 创建非root用户
RUN groupadd -r appuser && useradd -r -g appuser appuser
USER appuser

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar", "--spring.config.location=/app/config/application-prod.yml"]
```

#### 7.1.2 Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  dispatch-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - MYSQL_HOST=mysql
      - REDIS_HOST=redis
      - INFLUXDB_HOST=influxdb
    depends_on:
      - mysql
      - redis
      - influxdb
    networks:
      - dispatch-network

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: dispatch_system
      MYSQL_USER: dispatch_user
      MYSQL_PASSWORD: dispatch_password
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "3306:3306"
    networks:
      - dispatch-network

  redis:
    image: redis:6.2-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - dispatch-network

  influxdb:
    image: influxdb:2.0
    environment:
      INFLUXDB_DB: vehicle_data
      INFLUXDB_ADMIN_USER: admin
      INFLUXDB_ADMIN_PASSWORD: adminpassword
    volumes:
      - influxdb_data:/var/lib/influxdb2
    ports:
      - "8086:8086"
    networks:
      - dispatch-network

volumes:
  mysql_data:
  redis_data:
  influxdb_data:

networks:
  dispatch-network:
    driver: bridge
```

### 7.2 Kubernetes部署配置

#### 7.2.1 应用部署配置
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dispatch-system
  labels:
    app: dispatch-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dispatch-system
  template:
    metadata:
      labels:
        app: dispatch-system
    spec:
      containers:
      - name: dispatch-app
        image: dispatch-system:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: MYSQL_HOST
          value: "mysql-service"
        - name: REDIS_HOST
          value: "redis-service"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: dispatch-system-service
spec:
  selector:
    app: dispatch-system
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer
```

### 7.3 CI/CD Pipeline

#### 7.3.1 Jenkins Pipeline
```groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = 'your-registry.com'
        IMAGE_NAME = 'dispatch-system'
        KUBECONFIG = credentials('kubeconfig')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Test') {
            steps {
                sh 'mvn clean test'
            }
            post {
                always {
                    publishTestResults testResultsPattern: 'target/surefire-reports/*.xml'
                    publishCoverage adapters: [jacocoAdapter('target/site/jacoco/jacoco.xml')]
                }
            }
        }
        
        stage('Build') {
            steps {
                sh 'mvn clean package -DskipTests'
            }
        }
        
        stage('Docker Build') {
            steps {
                script {
                    def image = docker.build("${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}")
                    docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-registry-credentials') {
                        image.push()
                        image.push('latest')
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            steps {
                sh """
                    kubectl set image deployment/dispatch-system \
                        dispatch-app=${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER} \
                        --namespace=staging
                    kubectl rollout status deployment/dispatch-system --namespace=staging
                """
            }
        }
        
        stage('Integration Tests') {
            steps {
                sh 'mvn verify -Dtest.environment=staging'
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input message: '部署到生产环境？', ok: '确认部署'
                sh """
                    kubectl set image deployment/dispatch-system \
                        dispatch-app=${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER} \
                        --namespace=production
                    kubectl rollout status deployment/dispatch-system --namespace=production
                """
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        failure {
            emailext (
                subject: "构建失败: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: "构建失败，请检查: ${env.BUILD_URL}",
                to: "dev-team@company.com"
            )
        }
    }
}
```

## 8. 测试方案

### 8.1 单元测试

```java
@ExtendWith(MockitoExtension.class)
class VehicleDispatchAlgorithmTest {
    
    @Mock
    private MapService mapService;
    
    @Mock
    private VehicleRepository vehicleRepository;
    
    @InjectMocks
    private VehicleDispatchAlgorithm dispatchAlgorithm;
    
    @Test
    void testFindNearestAvailableVehicle() {
        // Given
        Location targetLocation = new Location(104.066801, 30.572815);
        List<Vehicle> availableVehicles = Arrays.asList(
            createVehicle(1L, 104.066901, 30.572915), // 距离约100米
            createVehicle(2L, 104.067801, 30.573815), // 距离约1公里
            createVehicle(3L, 104.066701, 30.572715)  // 距离约50米
        );
        
        when(mapService.calculateRoute(any(), any()))
            .thenReturn(new RouteInfo(1000, 300, TrafficStatus.SMOOTH));
        
        // When
        Vehicle nearestVehicle = dispatchAlgorithm
            .findNearestAvailableVehicle(targetLocation, availableVehicles);
        
        // Then
        assertThat(nearestVehicle).isNotNull();
        assertThat(nearestVehicle.getId()).isEqualTo(3L); // 最近的车辆
    }
    
    private Vehicle createVehicle(Long id, double longitude, double latitude) {
        Vehicle vehicle = new Vehicle();
        vehicle.setId(id);
        vehicle.setLocation(new Location(longitude, latitude));
        vehicle.setStatus(VehicleStatus.ONLINE);
        return vehicle;
    }
}
```

### 8.2 集成测试

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(locations = "classpath:application-test.properties")
class DispatchSystemIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private VehicleRepository vehicleRepository;
    
    @Autowired
    private StationRepository stationRepository;
    
    @Test
    void testCompleteDispatchFlow() {
        // 1. 准备测试数据
        Vehicle vehicle = createTestVehicle();
        vehicleRepository.save(vehicle);
        
        Station station = createTestStation();
        stationRepository.save(station);
        
        // 2. 模拟车辆位置变化
        VehicleLocationDto locationDto = VehicleLocationDto.builder()
            .vehicleId(vehicle.getId())
            .latitude(station.getLatitude())
            .longitude(station.getLongitude())
            .timestamp(Instant.now())
            .build();
        
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/v1/vehicles/location", locationDto, ApiResponse.class);
        
        // 3. 验证响应
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        
        // 4. 验证调度任务是否创建
        await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {
            ResponseEntity<TaskListResponse> tasksResponse = restTemplate.getForEntity(
                "/api/v1/dispatch/tasks?status=pending", TaskListResponse.class);
            assertThat(tasksResponse.getBody().getTasks()).isNotEmpty();
        });
    }
}
```

### 8.3 性能测试

```java
@Component
public class PerformanceTestRunner {
    
    @Autowired
    private VehicleMonitorService vehicleMonitorService;
    
    /**
     * 测试车辆位置更新性能
     */
    public void testVehicleLocationUpdatePerformance() {
        int vehicleCount = 1000;
        int updateCount = 100;
        
        List<VehicleLocationDto> locations = generateTestLocations(vehicleCount);
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        // 并发更新车辆位置
        locations.parallelStream().forEach(location -> {
            for (int i = 0; i < updateCount; i++) {
                vehicleMonitorService.updateVehicleLocation(location);
            }
        });
        
        stopWatch.stop();
        
        long totalUpdates = vehicleCount * updateCount;
        double updatesPerSecond = totalUpdates / (stopWatch.getTotalTimeSeconds());
        
        System.out.printf("性能测试结果: %d次更新耗时%.2f秒，TPS: %.2f\n", 
                         totalUpdates, stopWatch.getTotalTimeSeconds(), updatesPerSecond);
        
        // 验证性能要求：每秒至少处理1000次位置更新
        assertThat(updatesPerSecond).isGreaterThan(1000);
    }
}
```

## 9. 项目交付计划

### 9.1 交付物清单

1. **需求文档**
   - 系统需求规格说明书
   - 用户故事和验收标准
   - 接口设计文档

2. **设计文档**
   - 系统架构设计
   - 数据库设计文档
   - API接口文档

3. **源代码**
   - 后端服务代码
   - 前端应用代码
   - 移动端应用代码
   - 数据库脚本

4. **部署文档**
   - 环境搭建指南
   - 部署操作手册
   - 运维监控配置

5. **测试文档**
   - 测试计划和用例
   - 性能测试报告
   - 用户验收测试报告

6. **用户手册**
   - 系统操作手册
   - 移动端使用指南
   - 常见问题解答

### 9.2 验收标准

1. **功能验收**
   - 所有需求功能正常运行
   - "2-1-2"调度规则准确执行
   - 实时监控和告警正常

2. **性能验收**
   - 系统响应时间<3秒
   - 支持1000台车辆并发
   - 调度响应时间<15分钟

3. **稳定性验收**
   - 系统可用性≥99.5%
   - 7×24小时稳定运行
   - 故障恢复时间<30分钟

### 9.3 培训计划

1. **管理员培训**（2天）
   - 系统架构和功能介绍
   - 后台管理操作
   - 数据分析和报表使用
   - 故障排查和处理

2. **运维人员培训**（1天）
   - 移动端APP使用
   - 任务接收和执行流程
   - 异常情况处理

3. **技术人员培训**（3天）
   - 系统技术架构
   - 代码结构和开发规范
   - 部署和运维操作
   - 问题诊断和解决

---

**文档版本**：v1.0  
**创建日期**：2025-09-03  
**预计完成时间**：14周  
**技术负责人**：AI智能体